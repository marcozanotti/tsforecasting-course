---
title: "Time Series Dashboard"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    css: css/styles-default.css
    logo: img/logo.png
    social: ["menu"]
    source_code: https://github.com/marcozanotti/tsforecasting-course
    navbar:
      - { title: "About", href: "https://marcozanotti.netlify.app/", align: right }
      - { title: "Manual", href: "https://example.com/about", align: right }
runtime: shiny
---

<!-- Link to [Page 3](#page-3) -->
<!-- data-icon="fa-list" -->

<!-- modeltime issue with linear regression & cubist in refitting and oosf -->
<!-- reset dataset uploaded -->
<!-- cambiare logo -->
<!-- deployment su github actions -->

<!-- aggiungere metodi di ml -->
<!-- pensare e aggiungere il save del modello sia in Test & Evaluate sia in Optimize (da usare in Compare/Combine al posto dei default) -->
<!-- pensare e aggiungere la sezione di optimize tuning -->
<!-- pensare e aggiungere la sezione di ensemble-combine -->
<!-- pensare e aggiungere la sezione di compare-run competition -->
<!-- pensare e aggiungere la sezione di scenario forecasting + uncertainty + judgmental (gauges?) -->
<!-- pensare e aggiungere la sezione di feature engineering -->
<!-- modificare autput modello con parsing -->
<!-- documentazione in alto a destra -->

```{r setup, include=FALSE, message=FALSE}
source("R/utils.R")
source("R/utils-packages.R")
source("R/get_data.R")
source("R/transform_data.R")
source("R/hp_testing.R")
source("R/metrics.R")
source("R/fit_model.R")
source("R/generate_forecast.R")

# Packages
pkgs <- c(
  "tidyverse", "tsibbledata", "janitor", "skimr", "vroom",
  "forecast", "prophet", "glmnet", "earth", "kernlab", "kknn",
  "randomForest", "ranger", "xgboost", "treesnip", "lightgbm", "catboost",
  "Cubist", "rules",
  "tidymodels", "modeltime",
  "plotly", "DT", "timetk",
  "rmarkdown", "flexdashboard",
  "shiny", "shinyWidgets", "shinyjs", "shinymanager"
)
install_and_load(pkgs)

set_options()
datasets <- c(
  "Air Passengers", "EU Population", # "Electricity Demand", 
  "People Traffic", "Stock Price", "Tobacco Prod", ""
)
methods <- getOption("tsf.dashboard.methods")
ts_methods <- methods$ts
ml_methods <- methods$ml
ens_methods <- methods$ens
methods <- c(ts_methods, ml_methods)

methods_params <- getOption("tsf.dashboard.methods_params")
methods_params_cl <- methods_params |> 
  map(~ stringr::str_to_title(stringr::str_replace_all(., "_", " ")))
```



Data {data-orientation=rows}  
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
selectInput(
  inputId = "dataset", label = h4("Dataset"), 
  choices = datasets, selected = datasets[1], multiple = FALSE
)

h4("Upload your dataset: ")
h6("The dataset must be a .csv file containing columns 'date', 'id', 'frequency' and 'value'.")
fileInput(
  inputId = "upload_custom", label = NULL, accept = c(".csv"), multiple = FALSE,
  buttonLabel = "Browse...", placeholder = "No file"
)
actionButton(inputId = "data_import", label = "Import", icon = icon("upload"))
actionButton(inputId = "data_reset", label = "Reset", icon = icon("sync"))
observeEvent(
  eventExpr = input$data_reset, 
  handlerExpr = {
    reset("upload_custom")
    updateSelectInput(session = session, inputId = "dataset", selected = datasets[1])
})

br()
br()

prettyRadioButtons(
  inputId = "table_type", label = h5("Show:"), 
  choices = c("Preview", "Structure", "Summary")
)
```

```{r}
data_selected <- reactive({

  if (input$data_import & !input$data_reset) {
    req(input$upload_custom)
    ext <- tools::file_ext(input$upload_custom$datapath)
    validate(need(ext == "csv", "Please upload a csv file"))
    updateSelectInput(session = session, inputId = "dataset", selected = "") # important to activate date_range input
    get_data("custom", path = input$upload_custom$datapath)
  } else {
    get_data(input$dataset)
  }
  
})

ts_freq <- reactive({
  data_selected()$frequency |> unique() |> parse_frequency()
})
```


Row 1 {data-height=100}
---------------------------------------------------------------------------

### 

```{r}
output$data_table <- renderDT({
  data_selected() |>
      datatable(
        options = list(
          ordering = TRUE,
          pageLength = 20,
          lengthChange = TRUE,
          # FALSE
          searching = TRUE,
          # FALSE
          info = FALSE,
          paging = TRUE,
          scrollY = 560,
          # 250
          scrollCollapse = TRUE
        )
      )
})
output$data_str <- renderPrint({ str(data_selected()) })
output$data_summ <- renderPrint({ skim(data_selected()) })

conditionalPanel(
  condition = "input.table_type == 'Preview'",
  DTOutput(outputId = "data_table")
)
conditionalPanel(
  condition = "input.table_type == 'Structure'",
  verbatimTextOutput(outputId = "data_str")
)
conditionalPanel(
  condition = "input.table_type == 'Summary'",
  verbatimTextOutput(outputId = "data_summ")
)
```



Visualize, & Transform {data-navmenu="Analyze" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
h3("Visualize")

dateRangeInput(
  inputId = "date_range", label = NULL,
  start = as.Date("1940-01-01"), end = as.Date("2023-12-31")
)
observeEvent(
  eventExpr = input$dataset,
  handlerExpr = {
    req(data_selected())
    updateDateRangeInput(
      session = session, inputId = "date_range",
      start = min(data_selected()$date), end = max(data_selected()$date)
    )
  }
)

materialSwitch(
  inputId = "smooth_line", label = h5("Smooth Line"), 
  value = TRUE, status = "primary", inline = TRUE
)

numericInput(
  inputId = "acf_lag", label = h5("ACF Lag"),
  value = 48, min = 1, max = 300, step = 1, width = "45%"
)
observeEvent(
  eventExpr = input$dataset, 
  handlerExpr = {
    updateNumericInput(
      session = session, inputId = "acf_lag", 
      value = ifelse(ts_freq() < 60, ts_freq() * 3, 150), 
      min = 1, max = 300, step = 1
    )
  }
)

hr()
h3("Missing Imputation")
switchInput(inputId = "impute", value = FALSE, size = "mini")

hr()
h3("Transform")

materialSwitch(inputId = "log", label = "Log", value = FALSE, status = "primary")
materialSwitch(inputId = "boxcox", label = "Box-Cox", value = FALSE, status = "primary")
materialSwitch(inputId = "norm", label = "Normalize", value = FALSE, status = "primary")
materialSwitch(inputId = "stand", label = "Standardize", value = FALSE, status = "primary")
materialSwitch(inputId = "diff", label = "Diff", value = FALSE, status = "primary")
materialSwitch(inputId = "sdiff", label = "Seasonal Diff", value = FALSE, status = "primary")

br()

actionButton(inputId = "transf_reset", label = "Reset", icon = icon("sync"))
observeEvent(
  eventExpr = input$transf_reset, 
  handlerExpr = {
    updateMaterialSwitch(session = session, inputId = "smooth_line", value = TRUE)
    updateNumericInput(session = session, inputId = "acf_lag", value = ifelse(ts_freq() < 60, ts_freq() * 3, ts_freq()))
    updateSwitchInput(session = session, inputId = "impute", value = FALSE)
    updateMaterialSwitch(session = session, inputId = "log", value = FALSE)
    updateMaterialSwitch(session = session, inputId = "boxcox", value = FALSE)
    updateMaterialSwitch(session = session, inputId = "norm", value = FALSE)
    updateMaterialSwitch(session = session, inputId = "stand", value = FALSE)
    updateMaterialSwitch(session = session, inputId = "diff", value = FALSE)
    updateMaterialSwitch(session = session, inputId = "sdiff", value = FALSE)
  }
)
```

```{r}
data_transformed <- reactive({
  data_selected() |> 
    impute_data(params = input, freq = ts_freq()) |> 
    transform_data(section = "viz_transf", params = input, freq = ts_freq()) |> 
    filter(between(date, input$date_range[1], input$date_range[2]))
})
```


Row 1 {data-height=400}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
output$ts_plot_smooth <- renderPlotly({
  data_transformed() |>
    timetk::plot_time_series(
      .date_var = date, .value = value,
      .smooth = input$smooth_line, # ifelse(ts_freq() > 60, FALSE, TRUE),
      .interactive = TRUE
    )
})
plotlyOutput(outputId = "ts_plot_smooth")
```

### {.no-padding}

```{r}
output$autocorr_plot <- renderPlotly({
  data_transformed() |>
    timetk::plot_acf_diagnostics(
      .date_var = date, .value = value, 
      .lags = input$acf_lag, # ifelse(ts_freq() < 60, ts_freq() * 3, 150)
      .interactive = TRUE,
      .title = "Autocorrelation", .y_lab = NULL,
    )
})
plotlyOutput(outputId = "autocorr_plot")
```


Row 2 {data-height=600}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
output$decomp_plot <- renderPlotly({
    data_transformed() |>
      timetk::plot_stl_diagnostics(
    .date_var = date, .value = value, 
    .feature_set = c("season", "trend", "remainder"), .interactive = TRUE,
    .title = "Decomposition"
  )
})
plotlyOutput(outputId = "decomp_plot")
```

### {.no-padding}

```{r}
output$season_plot <- renderPlotly({
  data_transformed() |>
    timetk::plot_seasonal_diagnostics(
      .date_var = date, .value = value, 
      .interactive = TRUE, .title = "Seasonality"
    )
})
plotlyOutput(outputId = "season_plot")
```



Anomaly Detection & Cleaning {data-navmenu="Analyze" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
h3("Anomaly Detection")

sliderInput(inputId = "alpha", label = h4("Confidence Level"), min = 0.01, max = 1, value = 0.02, step = 0.01)
sliderInput(inputId = "max_anomalies", label = h4("Max Anomalies (%)"), min = 0.01, max = 1, value = 0.1, step = 0.01)

hr()
h3("Anomaly Cleaning")
switchInput(inputId = "clean", value = FALSE, size = "mini")

br()

actionButton(inputId = "anomaly_reset", label = "Reset", icon = icon("sync"))
observeEvent(
  eventExpr = input$anomaly_reset, 
  handlerExpr = {
    updateSliderInput(session = session, inputId = "alpha", value = 0.02)
    updateSliderInput(session = session, inputId = "max_anomalies", value = 0.1)
    updateSwitchInput(session = session, inputId = "clean", value = FALSE)
  }
)
```

```{r}
data_cleaned <- reactive({
  data_transformed() |> clean_data(params = input)
})
```


Row 1 {data-height=650}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
output$anomaly_plot <- renderPlotly({
  data_transformed() |>
    timetk::plot_anomaly_diagnostics(
      .date_var = date, .value = value, 
      .alpha = input$alpha, .max_anomalies = input$max_anomalies,
      .interactive = TRUE, .title = "Anomaly Plot", .legend_show = FALSE
    )
})
plotlyOutput(outputId = "anomaly_plot")
```


Row 2 {data-height=350}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
output$clean_plot <- renderPlotly({
  data_cleaned() |>
    timetk::plot_time_series(
      .date_var = date, .value = value,
      .smooth = FALSE, .interactive = TRUE, 
      .title = "Cleaned Time Series"
    )
})
plotlyOutput(outputId = "clean_plot")
```



Hypothesis Testing {data-navmenu="Analyze" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
h3("Normality Tests")
h5("Shapiro-Wilk and Jarque-Bera")
br()

hr()
h3("Autocorrelation Tests")
h5("Ljung-Box and Box-Pierce")
br()

hr()
h3("Stationarity Tests")
h5("ADF, PP and KPSS")

br()
br()
br()
materialSwitch(inputId = "test_log", label = "Test on log?", value = FALSE, status = "primary")
materialSwitch(inputId = "test_diff", label = "Test on diff?", value = FALSE, status = "primary")
materialSwitch(inputId = "test_sdiff", label = "Test on seasonal diff?", value = FALSE, status = "primary")
```

```{r}
data_test <- reactive({
  data_selected() |> 
    transform_data(section = "test_hp", params = input, freq = ts_freq())
})

test_results <- reactive({
  data_test() |> compute_hptests()
})
```


Row 1 {data-height=500}
---------------------------------------------------------------------------

### 

```{r}
output$test_table <- renderDT({
  test_results() |>
    datatable(
      options = list(
        ordering = FALSE,
        pageLength = 20,
        lengthChange = FALSE,
        searching = FALSE,
        info = FALSE,
        paging = FALSE
      ), 
      rownames = FALSE
    )
})
DTOutput(outputId = "test_table")
```


Row 1 {data-height=500}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
output$test_ts_plot <- renderPlotly({
  data_test() |>
    timetk::plot_time_series(
      .date_var = date, .value = value,
      .smooth = FALSE, .interactive = TRUE, .title = NULL
    )
})
plotlyOutput(outputId = "test_ts_plot")
```

### {.no-padding}

```{r}
output$test_autocorr_plot <- renderPlotly({
  data_test() |>
    timetk::plot_acf_diagnostics(
      .date_var = date, .value = value, 
      .lags = ifelse(ts_freq() < 60, ts_freq() * 3, 150),
      .interactive = TRUE, .title = NULL, .y_lab = NULL
    )
})
plotlyOutput(outputId = "test_autocorr_plot")
```



Feature Engineering {data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
useShinyjs(rmd = TRUE) # use Shiny JavaScript to allow delay on buttons
```

Row 1 {data-height=500}
---------------------------------------------------------------------------

### Features {.no-padding}

COMING SOON


Test & Evaluate {data-navmenu="Forecast" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

*Forecast - Test & Evaluate* 
```{r}
useShinyjs(rmd = TRUE) # use Shiny JavaScript to allow delay on buttons
dropdownButton(
  numericInput(
    inputId = "n_future", label = "Forecast Horizon", 
    value = 12, min = 1, max = Inf, step = 1, width = "100%"
  ),
  numericInput(
    inputId = "n_assess", label = "Assessment Period", 
    value = 24, min = 1, max = Inf, step = 1, width = "100%"
  ), 
  prettyRadioButtons(
    inputId = "assess_type", label = "Assessment Type", 
    choices = c("Expanding", "Rolling"), selected = "Rolling", 
    inline = TRUE
  ),
  icon = icon("gear"), width = "200px", size = "sm", circle = TRUE,
  tooltip = tooltipOptions(title = "Click to see inputs!")
)

pickerInput(
  inputId = "method", label = h3("Forecast Algorithm"), multiple = FALSE,
  choices = list(`Time Series` = ts_methods, `Machine Learning` = ml_methods), 
  selected = ts_methods[1]
)

actionButton(inputId = "apply_forecast", label = "Forecast!", icon = icon("play"))
actionButton(inputId = "tsf_reset", label = "Reset", icon = icon("sync"))
observeEvent(
  eventExpr = input$tsf_reset, 
  handlerExpr = {
    updateNumericInput(session = session, inputId = "n_future", value = 12)
    updateNumericInput(session = session, inputId = "n_assess", value = 24)
    updatePrettyRadioButtons(session = session, inputId = "assess_type", selected = "Rolling")
    updatePickerInput(session = session, inputId = "method", selected = ts_methods[1])
    updateNumericInput(session = session, inputId = "window_size", value = 12)
    shinyjs::delay(ms = 300, expr = {shinyjs::click(id = "apply_forecast")})
  }
)

br() # break rule
br() # break rule

# Naive
conditionalPanel(
  condition = "input.method == 'Naive'",
  h5("Algorithm hyperparameters: "),
  h6("No hyperparameters for this algorithm!")
)

# Seasonal Naive
conditionalPanel(
  condition = "input.method == 'Seasonal Naive'",
  h5("Algorithm hyperparameters: "),
  h6("No hyperparameters for this algorithm!")
)

# Rolling Average
conditionalPanel(
  condition = "input.method == 'Rolling Average'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "window_size", label = "Window Size", value = get_default("window_size"), min = 1)
)

# ETS
conditionalPanel(
  condition = "input.method == 'ETS'",
  h5("Algorithm hyperparameters: "),
  awesomeCheckbox(inputId = "auto_ets", label = "Automatic estimation?", value = get_default("auto_ets")),
  selectInput(inputId = "error", label = "Error", choices = c("additive", "multiplicative"), selected = get_default("error")),
  selectInput(inputId = "trend", label = "Trend", choices = c("additive", "multiplicative", "none"), selected = get_default("trend")),
  selectInput(inputId = "season", label = "Seasonality", choices = c("additive", "multiplicative", "none"), selected = get_default("season")),
  selectInput(inputId = "damping", label = "Damped Trend", choices = c("damped", "none"), selected = get_default("damping")),
  numericInput(inputId = "smooth_level", label = "Alpha", value = get_default("smooth_level"), min = 0, max = 1),
  numericInput(inputId = "smooth_trend", label = "Beta", value = get_default("smooth_trend"), min = 0, max = 1),
  numericInput(inputId = "smooth_season", label = "Gamma", value = get_default("smooth_season"), min = 0, max = 1)
)

# Theta
conditionalPanel(
  condition = "input.method == 'Theta'",
  h5("Algorithm hyperparameters: "),
  h6("No hyperparameters for this algorithm!"),
  h6("This algorithm is fully automatic!")
)

# SARIMA
conditionalPanel(
  condition = "input.method == 'SARIMA'",
  h5("Algorithm hyperparameters: "),
  awesomeCheckbox(inputId = "auto_arima", label = "Automatic estimation?", value = get_default("auto_arima")),
  sliderInput(inputId = "non_seasonal_ar", label = "p", value = get_default("non_seasonal_ar"), min = 0, max = 5, step = 1),
  sliderInput(inputId = "non_seasonal_differences", label = "d", value = get_default("non_seasonal_differences"), min = 0, max = 2, step = 1),
  sliderInput(inputId = "non_seasonal_ma", label = "q", value = get_default("non_seasonal_ma"), min = 0, max = 5, step = 1),
  sliderInput(inputId = "seasonal_ar", label = "P", value = get_default("seasonal_ar"), min = 0, max = 5, step = 1),
  sliderInput(inputId = "seasonal_differences", label = "D", value = get_default("seasonal_differences"), min = 0, max = 2, step = 1),
  sliderInput(inputId = "seasonal_ma", label = "Q", value = get_default("seasonal_ma"), min = 0, max = 5, step = 1)
)

# TBATS
conditionalPanel(
  condition = "input.method == 'TBATS'",
  h5("Algorithm hyperparameters: "),
  awesomeCheckbox(inputId = "auto_tbats", label = "Automatic estimation?", value = get_default("auto_tbats")),
  numericInput(inputId = "tbats_seasonal_period_1", label = "Seasonal Period 1", value = get_default("tbats_seasonal_period_1"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "tbats_seasonal_period_2", label = "Seasonal Period 2", value = get_default("tbats_seasonal_period_2"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "tbats_seasonal_period_3", label = "Seasonal Period 3", value = get_default("tbats_seasonal_period_3"), min = 0, max = Inf, step = 1)
)

# STLM
conditionalPanel(
  condition = "input.method == 'STLM'",
  h5("Algorithm hyperparameters: "),
  awesomeCheckbox(inputId = "auto_stlm", label = "Automatic estimation?", value = get_default("auto_stlm")),
  prettyRadioButtons(inputId = "trend_model", label = "Trend Model", choices = c("ETS", "ARIMA"), inline = TRUE, selected = get_default("trend_model")),
  numericInput(inputId = "stlm_seasonal_period_1", label = "Seasonal Period 1", value = get_default("stlm_seasonal_period_1"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "stlm_seasonal_period_2", label = "Seasonal Period 2", value = get_default("stlm_seasonal_period_2"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "stlm_seasonal_period_3", label = "Seasonal Period 3", value = get_default("stlm_seasonal_period_3"), min = 0, max = Inf, step = 1)
)

# Prophet
conditionalPanel(
  condition = "input.method == 'Prophet'",
  h5("Algorithm hyperparameters: "),
  awesomeCheckbox(inputId = "auto_prophet", label = "Automatic estimation?", value = get_default("auto_prophet")),
  prettyRadioButtons(inputId = "growth", label = "Growth", choices = c("linear", "logistic"), inline = TRUE, selected = get_default("growth")),
  conditionalPanel(
    condition = "input.growth == 'logistic'",
    numericInput(inputId = "logistic_cap", label = "Logistic Cap", value = get_default("logistic_cap"), min = -Inf, max = Inf, step = 1),
    numericInput(inputId = "logistic_floor", label = "Logistic Floor", value = get_default("logistic_floor"), min = -Inf, max = Inf, step = 1)
  ),
  numericInput(inputId = "changepoint_num", label = "Changepoints (num)", value = get_default("changepoint_num"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "changepoint_range", label = "Changepoints (range)", value = get_default("changepoint_range"), min = 0, max = 1),
  prettyRadioButtons(inputId = "prophet_season", label = "Seasonality", choices = c("additive", "multiplicative"), inline = TRUE, selected = get_default("prophet_season")),
  awesomeCheckbox(inputId = "seasonality_yearly", label = "Yearly Seasonality?", value = get_default("seasonality_yearly")),
  awesomeCheckbox(inputId = "seasonality_weekly", label = "Weekly Seasonality?", value = get_default("seasonality_weekly")),
  awesomeCheckbox(inputId = "seasonality_daily", label = "Daily Seasonality?", value = get_default("seasonality_daily")),
  numericInput(inputId = "prior_scale_changepoints", label = "Changepoint Flexibility", value = get_default("prior_scale_changepoints") , min = 0, max = 1),
  numericInput(inputId = "prior_scale_seasonality", label = "Seasonality Stength", value = get_default("prior_scale_seasonality"), min = 0, max = Inf),
  numericInput(inputId = "prior_scale_holidays", label = "Holidays Strength", value = get_default("prior_scale_holidays"), min = 0, max = Inf)
)

# Linear Regression
conditionalPanel(
  condition = "input.method == 'Linear Regression'",
  h5("Algorithm hyperparameters: "),
  h6("No hyperparameters for this algorithm!")
)

# Elastic Net
conditionalPanel(
  condition = "input.method == 'Elastic Net'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "penalty", label = "Penalty", value = get_default("penalty"), min = 0, max = 100),
  numericInput(inputId = "mixture", label = "Mixture", value = get_default("mixture"), min = 0, max = 1)
)

# MARS
conditionalPanel(
  condition = "input.method == 'MARS'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "num_terms", label = "Num Terms", value = get_default("num_terms"), min = 0, max = 200),
  sliderInput(inputId = "prod_degree", label = "Interactions Degree", value = get_default("prod_degree"), min = 0, max = 5, step = 1),
  selectInput(inputId = "prune_method", label = "Prune Method", choices = c("backward", "forward", "none"), selected = get_default("prune_method"))
)

# KNN
conditionalPanel(
  condition = "input.method == 'KNN'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "neighbors", label = "K-neighbors", value = get_default("neighbors"), min = 0, max = Inf)
)

# SVM
conditionalPanel(
  condition = "input.method == 'SVM'",
  h5("Algorithm hyperparameters: "),
  prettyRadioButtons(inputId = "boundary", label = "Boundary Type", choices = c("linear", "radial"), inline = TRUE, selected = get_default("boundary")),
  numericInput(inputId = "cost", label = "Cost", value = get_default("cost"), min = 0, max = Inf),
  numericInput(inputId = "margin", label = "Margin", value = get_default("margin"), min = 0, max = Inf)
)

# Random Forest
conditionalPanel(
  condition = "input.method == 'Random Forest'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "rf_mtry", label = "Random Predictors", value = get_default("rf_mtry"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "rf_trees", label = "Trees", value = get_default("rf_trees"), min = 1, max = Inf, step = 1),
  numericInput(inputId = "rf_min_n", label = "Min Node Size", value = get_default("rf_min_n"), min = 1, max = Inf, step = 1)
)

# Boosted Trees
conditionalPanel(
  condition = "input.method == 'Boosted Trees'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "boost_mtry", label = "Random Predictors", value = get_default("boost_mtry"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "boost_trees", label = "Trees", value = get_default("boost_trees"), min = 1, max = Inf, step = 1),
  numericInput(inputId = "boost_min_n", label = "Min Node Size", value = get_default("boost_min_n"), min = 1, max = Inf, step = 1),
  numericInput(inputId = "boost_tree_depth", label = "Tree Depth", value = get_default("boost_tree_depth"), min = 1, max = Inf),
  numericInput(inputId = "boost_learn_rate", label = "Learning Rate", value = get_default("boost_learn_rate"), min = 0, max = 1),
  numericInput(inputId = "boost_loss_reduction", label = "Min Loss Reduction", value = get_default("boost_loss_reduction"), min = 0, max = 1),
  numericInput(inputId = "boost_sample_size", label = "Sample Size", value = get_default("boost_sample_size"), min = 0, max = 1)
)

# Cubist
conditionalPanel(
  condition = "input.method == 'Cubist'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "committees", label = "Num Members", value = get_default("committees"), min = 0, max = 100, step = 1),
  sliderInput(inputId = "cub_neighbors", label = "Neighbors", value = get_default("cub_neighbors"), min = 0, max = 9, step = 1),
  numericInput(inputId = "max_rules", label = "Max Rules", value = get_default("max_rules"), min = 1, max = Inf, step = 1)
)
```

```{r}
forecast_results <- eventReactive(
  eventExpr = input$apply_forecast,
  valueExpr = {
    data_cleaned() |>
      fit_model(
        method = input$method, params = input, 
        n_assess = input$n_assess, assess_type = input$assess_type, 
        seed = 1992
      ) |> 
      generate_forecast(
        data = data_cleaned(), method = input$method, n_future = input$n_future,
        n_assess = input$n_assess, assess_type = input$assess_type
    )
  }
)
```


Row 1 {data-height=500}
---------------------------------------------------------------------------

### Test Forecasts {.no-padding}

```{r}
output$plot_test_forecast <- renderPlotly({
  forecast_results()$test_forecast |> 
    plot_modeltime_forecast(.legend_show = FALSE, .title = FALSE, .conf_interval_fill = "lightblue")
})
plotlyOutput(outputId = "plot_test_forecast")
```

<!-- ### Validation Plan {.no-padding} -->

<!-- ```{r} -->
<!-- output$plot_splits <- renderPlotly({ -->
<!--   forecast_results()$splits |>  -->
<!--     tk_time_series_cv_plan() |> -->
<!--     plot_time_series_cv_plan(date, value, .title = NULL, .legend_show = FALSE) -->
<!-- }) -->
<!-- plotlyOutput(outputId = "plot_splits") -->
<!-- ``` -->

### Out-of-Sample Forecasts {.no-padding}

```{r}
output$plot_oos_forecast <- renderPlotly({
  forecast_results()$oos_forecast |> 
    plot_modeltime_forecast(.legend_show = FALSE, .title = FALSE, .conf_interval_fill = "lightblue")
})
plotlyOutput(outputId = "plot_oos_forecast")
```


Row 2 {data-height=500} 
---------------------------------------------------------------------------

### Evaluation Metrics {.no-padding}

```{r}
output$accuracy_table <- renderDT({
  forecast_results()$accuracy |>
    select(-1, -2) |>
    rename("Type" = ".type") |>
    rename_with(.fn = toupper, .cols = -1) |>
    relocate("ME", .after = 1) |> 
    mutate(across(where(is.numeric), ~round(., 2))) |>
    pivot_longer(cols = -1, names_to = "Metric", values_to = "Value") |>
    pivot_wider(names_from = "Type", values_from = "Value") |>
    datatable(
      options = list(
        ordering = FALSE,
        pageLength = 20,
        lengthChange = FALSE,
        searching = FALSE,
        info = FALSE,
        paging = FALSE
      ), 
      rownames = FALSE
    )
})
DTOutput(outputId = "accuracy_table")
```

### Algorithm Summary {.no-padding}

```{r}
output$model_summary <- renderPrint({
  forecast_results()$fit
})
verbatimTextOutput(outputId = "model_summary")
```

### Residuals Time Plot {.no-padding}

```{r}
output$plot_resid_ts <- renderPlotly({
  forecast_results()$residuals |> 
    select(.index, .residuals) |> 
    set_names(c("date", "value")) |> 
    timetk::plot_time_series(
      .date_var = date, .value = value,
      .smooth = FALSE, .interactive = TRUE, .title = NULL
    )
})
plotlyOutput(outputId = "plot_resid_ts")
```

### Residuals ACF {.no-padding}

```{r}
output$plot_resid_acf <- renderPlotly({
  forecast_results()$residuals |> 
    select(.index, .residuals) |> 
    set_names(c("date", "value")) |> 
    timetk::plot_acf_diagnostics(
      .date_var = date, .value = value, 
      .interactive = TRUE, .title = NULL, .y_lab = NULL,
    )
})
plotlyOutput(outputId = "plot_resid_acf")
```


```{r}
# testing
# data_selected <- get_data(datasets[1])
# ts_freq <- data_selected$frequency |> unique() |> parse_frequency()
# input <- list(
#   n_future = 12,
#   n_assess = 24,
#   assess_type = "Rolling",
#   method = "ETS",
#   error = "auto",
#   trend = "auto",
#   season = "auto",
#   damping = "auto",
#   smooth_level = 0.1,
#   smooth_trend = 0.1,
#   smooth_season = 0.1
# )
# input <- list(
#   n_future = 12,
#   n_assess = 24,
#   assess_type = "Rolling",
#   method = "Elastic Net",
#   penalty = 1,
#   mixture = 0.5
# )
# input <- list(
#   n_future = 12,
#   n_assess = 24,
#   assess_type = "Rolling",
#   method = "Rolling Average",
#   window_size = 12
# )
# 
# fitted_model <- fit_model(
#   data = data_selected, method = input$method, params = input,
#   n_assess = input$n_assess, assess_type = input$assess_type, seed = 1992
# )
# 
# forecast_results <- generate_forecast(
#   fitted_model = fitted_model, data = data_selected,
#   method = input$method, n_future = input$n_future, 
#   n_assess = input$n_assess, assess_type = input$assess_type
# )
# 
# data_selected |> 
#   fit_model(
#     method = input$method,
#     params = input,
#     n_assess = input$n_assess,
#     assess_type = input$assess_type,
#     seed = 1992
#   ) |>
#   generate_forecast(
#     data = data_selected,
#     method = input$method,
#     n_future = input$n_future,
#     n_assess = input$n_assess,
#     assess_type = input$assess_type
#   )
# 
#   
# 
# data = data_selected
# method = input$method
# params = input
# n_assess = input$n_assess
# assess_type = input$assess_type
# seed = 1992
# data_splits = fitted_model$splits
# fitted_model = fitted_model$fit
# n_future = input$n_future
# 
# forecast_results$splits |>
#   tk_time_series_cv_plan() |>
#   plot_time_series_cv_plan(date, value)
# forecast_results$fit
# forecast_results$residuals
# forecast_results$accuracy
# forecast_results$test_forecast |> plot_modeltime_forecast()
# forecast_results$oos_forecast |> plot_modeltime_forecast()
```




Optimize {data-navmenu="Forecast" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

*Forecast - Optimize*  
```{r}
useShinyjs(rmd = TRUE) # use Shiny JavaScript to allow delay on buttons
dropdownButton(
  numericInput(
    inputId = "tune_n_future", label = "Forecast Horizon", 
    value = 12, min = 1, max = Inf, step = 1, width = "100%"
  ),
  numericInput(
    inputId = "tune_n_assess", label = "Assessment Period", 
    value = 24, min = 1, max = Inf, step = 1, width = "100%"
  ), 
  prettyRadioButtons(
    inputId = "tune_assess_type", label = "Assessment Type", 
    choices = c("Expanding", "Rolling"), selected = "Rolling", 
    inline = TRUE
  ),
  prettyRadioButtons(
    inputId = "tune_valid_type", label = "Validation Type", 
    choices = c("Time Series CV", "K-Fold CV"), selected = "Time Series CV", 
    inline = TRUE
  ),
  sliderInput(
    inputId = "tune_k", label = "Folds", 
    min = 2, max = 10, value = 5, step = 1
  ),
  icon = icon("gear"), width = "200px", size = "sm", circle = TRUE,
  tooltip = tooltipOptions(title = "Click to see inputs!")
)

pickerInput(
  inputId = "tune_method", label = h3("Forecast Algorithm"), multiple = FALSE,
  choices = list(`Time Series` = ts_methods, `Machine Learning` = ml_methods), 
  selected = ml_methods[2]
)

actionButton(inputId = "tune_apply_forecast", label = "Forecast!", icon = icon("play"))
actionButton(inputId = "tune_reset", label = "Reset", icon = icon("sync"))
observeEvent(
  eventExpr = input$tune_reset, 
  handlerExpr = {
    updateNumericInput(session = session, inputId = "tune_n_future", value = 12)
    updateNumericInput(session = session, inputId = "tune_n_assess", value = 24)
    updatePrettyRadioButtons(session = session, inputId = "tune_assess_type", selected = "Rolling")
    updatePrettyRadioButtons(session = session, inputId = "tune_valid_type", selected = "Time Series CV")
    updateSliderInput(session = session, inputId = "tune_k", value = 5)
    updateSelectInput(session = session, inputId = "tune_method", selected = ml_methods[2])
    updatePickerInput(session = session, inputId = "tune_elanet", selected = methods_params_cl[["Elastic Net"]][2])
    # shinyjs::delay(ms = 300, expr = {shinyjs::click(id = "tune_apply_forecast")})
  }
)

br() # break rule
br() # break rule

# Elastic Net
conditionalPanel(
  condition = "input.tune_method == 'Elastic Net'",
  h5("Algorithm hyperparameters to optimize: "),
  pickerInput(
    inputId = "tune_elanet", label = NULL, 
    choices = methods_params_cl[["Elastic Net"]], multiple = TRUE, 
    selected = methods_params_cl[["Elastic Net"]][2],
    options = list("actions-box" = TRUE)
  )
)
```

Row 1 {data-height=500}
---------------------------------------------------------------------------

### Forecasts Results {.no-padding}

COMING SOON



Compare {data-navmenu="Forecast" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

*Forecast - Compare*
```{r}
useShinyjs(rmd = TRUE) # use Shiny JavaScript to allow delay on buttons
dropdownButton(
  numericInput(
    inputId = "comp_n_future", label = "Forecast Horizon", 
    value = 12, min = 1, max = Inf, step = 1, width = "100%"
  ),
  numericInput(
    inputId = "comp_n_assess", label = "Assessment Period", 
    value = 24, min = 1, max = Inf, step = 1, width = "100%"
  ), 
  prettyRadioButtons(
    inputId = "comp_assess_type", label = "Assessment Type", 
    choices = c("Expanding", "Rolling"), selected = "Rolling", 
    inline = TRUE
  ),
  icon = icon("gear"), width = "200px", size = "sm", circle = TRUE,
  tooltip = tooltipOptions(title = "Click to see inputs!")
)

pickerInput(
  inputId = "comp_method", label = h3("Forecast Algorithm"), multiple = TRUE,
  choices = list(`Time Series` = ts_methods, `Machine Learning` = ml_methods), 
  selected = ts_methods[c(4, 6)], options = list("actions-box" = TRUE)
)

br()
materialSwitch(inputId = "comp_tune", label = "Tune algorithms?", value = FALSE, status = "primary")
br()

actionButton(inputId = "comp_apply_forecast", label = "Forecast!", icon = icon("play"))
actionButton(inputId = "comp_reset", label = "Reset", icon = icon("sync"))
observeEvent(
  eventExpr = input$comp_reset, 
  handlerExpr = {
    updateNumericInput(session = session, inputId = "comp_n_future", value = 12)
    updateNumericInput(session = session, inputId = "comp_n_assess", value = 24)
    updatePrettyRadioButtons(session = session, inputId = "comp_assess_type", selected = "Rolling")
    updatePickerInput(session = session, inputId = "comp_method", selected = ts_methods[c(4, 6)])
    updateMaterialSwitch(session = session, inputId = "comp_tune", value = FALSE)
    # shinyjs::delay(ms = 300, expr = {shinyjs::click(id = "tune_apply_forecast")})
  }
)
```

Row 1 {data-height=500}
---------------------------------------------------------------------------

### Forecasts Results {.no-padding}

COMING SOON



Combine {data-navmenu="Forecast" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

*Forecast - Combine*
```{r}
useShinyjs(rmd = TRUE) # use Shiny JavaScript to allow delay on buttons
dropdownButton(
  numericInput(
    inputId = "ens_n_future", label = "Forecast Horizon", 
    value = 12, min = 1, max = Inf, step = 1, width = "100%"
  ),
  numericInput(
    inputId = "ens_n_assess", label = "Assessment Period", 
    value = 24, min = 1, max = Inf, step = 1, width = "100%"
  ), 
  prettyRadioButtons(
    inputId = "ens_assess_type", label = "Assessment Type", 
    choices = c("Expanding", "Rolling"), selected = "Rolling", 
    inline = TRUE
  ),
  icon = icon("gear"), width = "200px", size = "sm", circle = TRUE,
  tooltip = tooltipOptions(title = "Click to see inputs!")
)

pickerInput(
  inputId = "ens_method", label = h3("Forecast Algorithms"), 
  choices = list(`Time Series` = ts_methods, `Machine Learning` = ml_methods), 
  selected = ts_methods[c(4, 6)], multiple = TRUE,
  options =  list(
    "actions-box" = FALSE,
    "max-options" = 5,
    "max-options-text" = "You can combine maximum 5 algorithms!"
  )
)

pickerInput(
  inputId = "ens_type", label = h3("Ensemble Method"), 
  choices = ens_methods, selected = ens_methods[1], multiple = TRUE,
  options =  list("actions-box" = TRUE)
)

br()
materialSwitch(inputId = "ens_tune", label = "Tune algorithms?", value = FALSE, status = "primary")
br()

actionButton(inputId = "ens_apply_forecast", label = "Forecast!", icon = icon("play"))
actionButton(inputId = "ens_reset", label = "Reset", icon = icon("sync"))
observeEvent(
  eventExpr = input$ens_reset, 
  handlerExpr = {
    updateNumericInput(session = session, inputId = "ens_n_future", value = 12)
    updateNumericInput(session = session, inputId = "ens_n_assess", value = 24)
    updatePrettyRadioButtons(session = session, inputId = "ens_assess_type", selected = "Rolling")
    updatePickerInput(session = session, inputId = "ens_method", selected = ts_methods[c(4, 6)])
    updatePickerInput(session = session, inputId = "ens_type", selected = ens_methods[1])
    updateMaterialSwitch(session = session, inputId = "ens_tune", value = FALSE)
    # shinyjs::delay(ms = 300, expr = {shinyjs::click(id = "tune_apply_forecast")})
  }
)
```

Row 1 {data-height=500}
---------------------------------------------------------------------------

### Forecasts Results {.no-padding}

COMING SOON



Scenario {data-navmenu="Forecast" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

*Forecast - Scenario*
```{r}
useShinyjs(rmd = TRUE) # use Shiny JavaScript to allow delay on buttons
dropdownButton(
  numericInput(
    inputId = "scn_n_future", label = "Forecast Horizon", 
    value = 12, min = 1, max = Inf, step = 1, width = "100%"
  ),
  numericInput(
    inputId = "scn_n_assess", label = "Assessment Period", 
    value = 24, min = 1, max = Inf, step = 1, width = "100%"
  ), 
  prettyRadioButtons(
    inputId = "scn_assess_type", label = "Assessment Type", 
    choices = c("Expanding", "Rolling"), selected = "Rolling", 
    inline = TRUE
  ),
  icon = icon("gear"), width = "200px", size = "sm", circle = TRUE,
  tooltip = tooltipOptions(title = "Click to see inputs!")
)

pickerInput(
  inputId = "scn_method", label = h3("Forecast Algorithms"), multiple = FALSE,
  choices = list(`Time Series` = ts_methods, `Machine Learning` = ml_methods), 
  selected = ts_methods[4]
)

actionButton(inputId = "scn_apply_forecast", label = "Forecast!", icon = icon("play"))
actionButton(inputId = "scn_reset", label = "Reset", icon = icon("sync"))
observeEvent(
  eventExpr = input$scn_reset, 
  handlerExpr = {
    updateNumericInput(session = session, inputId = "scn_n_future", value = 12)
    updateNumericInput(session = session, inputId = "scn_n_assess", value = 24)
    updatePrettyRadioButtons(session = session, inputId = "scn_assess_type", selected = "Rolling")
    updateSelectInput(session = session, inputId = "scn_method", selected = ts_methods[4])
    # shinyjs::delay(ms = 300, expr = {shinyjs::click(id = "tune_apply_forecast")})
  }
)
```

Row 1 {data-height=500}
---------------------------------------------------------------------------

### Forecasts Results {.no-padding}

COMING SOON

