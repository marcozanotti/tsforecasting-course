---
title: "Time Series Dashboard"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    css: css/styles-default.css
    logo: img/logo.png
    social: ["menu"]
    source_code: https://github.com/marcozanotti/tsforecasting-course
runtime: shiny
---

<!-- Link to [Page 3](#page-3) -->
<!-- data-icon="fa-list" -->

<!-- upload input per csv file con switch tra un dataset e l'altro e janitor -->
<!-- dataset timeseries del pacchetto forecast o tsibble -->
<!-- aggiungere metodi di time series -->
<!-- aggiungere metodi di ml -->
<!-- pensare e aggiungere la pulizia degli outliers -->
<!-- pensare e aggiungere le trasformazioni da applicare in fase di visualization e forecasting -->
<!-- pensare e aggiungere la sezione di feature engineering -->
<!-- pensare e aggiungere la sezione di ensemble -->
<!-- documentazione in alto a destra  -->
<!-- cambiare logo -->
<!-- deployment su github actions -->

```{r setup, include=FALSE, message=FALSE}
source("R/utils.R")
source("R/generate_forecast.R")
source("R/packages.R")

set_options()
ts_methods <- getOption("tsf.dashboard.methods")$ts
ml_methods <- getOption("tsf.dashboard.methods")$ml

useShinyjs(rmd = TRUE) # use Shiny JavaScript to allow delay on buttons
```

```{r auth}
# credentials <- read.csv("auth.txt")
# shinymanager::auth_ui(id = "auth")
# auth <- shiny::callModule(
#   module = shinymanager::auth_server,
#   id = "auth",
#   check_credentials = shinymanager::check_credentials(credentials)
# )
```

```{r data}
data1 <- tibble(
  date = seq.Date(from = as.Date("2010-01-01"), to = as.Date("2023-12-31"), by = "day"),
  id = "TS 1 - daily",
  value = rnorm(n = 5113, mean = 100, sd = 1000) + 1:5113 + sin(365)
)

data2 <- tibble(
  date = seq.Date(from = as.Date("2010-01-01"), to = as.Date("2023-12-31"), by = "week"),
  id = "TS 2 - weekly",
  value = rnorm(n = 731, mean = 100, sd = 1000) + 1:731 + sin(52)
)

data3 <- tibble(
  date = seq.Date(from = as.Date("2010-01-01"), to = as.Date("2023-12-31"), by = "month"),
  id = "TS 3 - monthly",
  value = rnorm(n = 168, mean = 100, sd = 1000) + 1:168 + sin(6)
)

data4 <- tibble(
  date = seq.Date(from = as.Date("2010-01-01"), to = as.Date("2023-12-31"), by = "quarter"),
  id = "TS 4 - quarterly",
  value = rnorm(n = 56, mean = 100, sd = 1000) + 1:56 + sin(2)
)

data5 <- tibble(
  date = seq.Date(from = as.Date("2010-01-01"), to = as.Date("2023-12-31"), by = "year"),
  id = "TS 5 - yearly",
  value = rnorm(n = 14, mean = 100, sd = 1000) + 1:14
)

data <- bind_rows(data1, data2, data3, data4, data5)
```



Data {data-orientation=rows}  
===========================================================================
<!-- data-navmenu="Data" -->

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
selectInput(
  inputId = "id", label = h4("Dataset"), 
  choices = unique(data$id), selected = unique(data$id)[3]
)

prettyRadioButtons(inputId = "table_type", label = NULL, choices = c("preview", "str", "summary"))

fileInput(
  inputId = "upload", label = h4("Load Dataset"), accept = c(".csv"),
  multiple = FALSE, buttonLabel = "Browse...", placeholder = "No file"
)

# input <- list(
#   id = unique(data$id)[3],
#   date_range = c(min(data$date), max(data$date))
# )
```

```{r}
data_upload <- reactive({
    req(input$upload)
    ext <- tools::file_ext(input$upload$datapath)
    validate(need(ext == "csv", "Please upload a csv file"))
    # data <<- 
    read_csv(input$upload$datapath, na = c("", "NA")) |> janitor::clean_names()
})

data_filtered_id <- reactive({
  # data_filtered <-
  data |>
    filter(id == input$id)
})

ts_freq <- reactive({
  # ts_freq <-
  data_filtered_id() |>
    tk_index() |>
    tk_get_frequency(period = "auto")
})
```


Row {data-height=100}
---------------------------------------------------------------------------

### Dataset Preview

```{r}
output$data_table <- renderDT({
  if (input$table_type == "preview") {
    data_filtered_id() |>
      datatable(
        options = list(
          ordering = TRUE,
          pageLength = 20,
          lengthChange = TRUE, # FALSE
          searching = TRUE, # FALSE
          info = FALSE,
          paging = TRUE,
          scrollY = 575, # 250
          scrollCollapse = TRUE
        )
      )
  } else if (input$table_type == "str") {
    str(data_filtered_id())
  } else {
    summary(data_filtered_id())
  }
})
DTOutput(outputId = "data_table")
```

<!-- Row {data-height=500} -->
<!-- --------------------------------------------------------------------------- -->

<!-- ### {.no-padding} -->

<!-- ```{r} -->
<!-- output$ts_plot <- renderPlotly({ -->
<!--   data_filtered() |> -->
<!--     timetk::plot_time_series( -->
<!--       .date_var = date, .value = value,  -->
<!--       .smooth = FALSE, .interactive = TRUE -->
<!--     ) -->
<!-- }) -->
<!-- plotlyOutput(outputId = "ts_plot") -->
<!-- ``` -->



Visualize & Transform {data-navmenu="Analyze" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
dateRangeInput(
  inputId = "date_range", label = h4("Date range"), 
  start = min(data$date), end = max(data$date) 
)

observeEvent(
  eventExpr = input$id, 
  handlerExpr = {
    updateDateRangeInput(
      session = session, inputId = "date_range", 
      start = min(data$date), end = max(data$date)
    )
  }
)

# input <- list(
#   id = unique(data$id)[3],
#   date_range = c(min(data$date), max(data$date))
# )
```

```{r}
data_filtered <- reactive({
  # data_filtered <-
  data_filtered_id() |>
    filter(between(date, input$date_range[1], input$date_range[2]))
})
```

Row {data-height=400}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
output$ts_plot_smooth <- renderPlotly({
  data_filtered() |>
    timetk::plot_time_series(.date_var = date, .value = value, .interactive = TRUE)
})
plotlyOutput(outputId = "ts_plot_smooth")
```

### {.no-padding}

```{r}
output$autocorr_plot <- renderPlotly({
  data_filtered() |>
    timetk::plot_acf_diagnostics(
      .date_var = date, .value = value, 
      .lags = ts_freq() * 3, .interactive = TRUE,
      .title = "Autocorrelation"
    )
})
plotlyOutput(outputId = "autocorr_plot")
```


Row {data-height=600}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
output$decomp_plot <- renderPlotly({
    data_filtered() |>
      timetk::plot_stl_diagnostics(
    .date_var = date, .value = value, 
    .feature_set = c("season", "trend", "remainder"), .interactive = TRUE,
    .title = "Decomposition"
  )
})
plotlyOutput(outputId = "decomp_plot")
```

### {.no-padding}

```{r}
output$season_plot <- renderPlotly({
  data_filtered() |>
    timetk::plot_seasonal_diagnostics(
      .date_var = date, .value = value, 
      .interactive = TRUE, .title = "Seasonality"
    )
})
plotlyOutput(outputId = "season_plot")
```



Anomaly Detection {data-navmenu="Analyze" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
sliderInput(inputId = "alpha", label = h3("Alpha"), min = 0.01, max = 1, value = 0.05, step = 0.01)

sliderInput(inputId = "max_anomalies", label = h3("Max Anomalies (%)"), min = 0.01, max = 1, value = 0.1, step = 0.01)
```


Row {data-height=100}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
output$anomaly_plot <- renderPlotly({
  data_filtered() |>
    timetk::plot_anomaly_diagnostics(
      .date_var = date, .value = value, 
      .alpha = input$alpha, .max_anomalies = input$max_anomalies,
      .interactive = TRUE, .title = "Anomaly Plot"
    )
})
plotlyOutput(outputId = "anomaly_plot")
```



TS Methods {data-navmenu="Forecast" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
sliderInput(
  inputId = "n_future", label = h4("Forecast Horizon"), 
  value = 12, min = 1, max = 60, step = 1
)

selectInput(
  inputId = "ts_method", label = h4("Forecast Method"), 
  choices = ts_methods, selected = ts_methods[1]
)

actionButton(inputId = "apply_ts_forecast", label = "Forecast!", icon = icon("play"))
actionButton(inputId = "ts_reset", label = "Reset", icon = icon("sync"))
observeEvent(
  eventExpr = input$ts_reset, 
  handlerExpr = {
    updateNumericInput(session = session, inputId = "n_future", value = 12)
    updateSelectInput(session = session, inputId = "ts_method", selected = ts_methods[1])
    shinyjs::delay(ms = 300, expr = {shinyjs::click(id = "apply_ts_forecast")})
  }
)

br() # break rule
br() # break rule

# Rolling Average
conditionalPanel(
  condition = "input.ts_method == 'Rolling Average'",
  h5("Method hyperparameters: "),
  numericInput(inputId = "window_size", label = "Window Size", value = 12, min = 1)
)

# ETS
conditionalPanel(
  condition = "input.ts_method == 'ETS'",
  h5("Method hyperparameters: "),
  selectInput(inputId = "error", label = "Error", choices = c("auto", "additive", "multiplicative"), selected = "auto"),
  selectInput(inputId = "trend", label = "Trend", choices = c("auto", "additive", "multiplicative", "none"), selected = "auto"),
  selectInput(inputId = "season", label = "Seasonality", choices = c("auto", "additive", "multiplicative", "none"), selected = "auto"),
  selectInput(inputId = "damping", label = "Damped Trend", choices = c("auto", "damped", "none"), selected = "auto"),
  numericInput(inputId = "smooth_level", label = "Alpha", value = 0.1, min = 0, max = 1),
  numericInput(inputId = "smooth_trend", label = "Beta", value = 0.1, min = 0, max = 1),
  numericInput(inputId = "smooth_season", label = "Gamma", value = 0.1, min = 0, max = 1)
)

# ARIMA
conditionalPanel(
  condition = "input.ts_method == 'ARIMA'",
  h5("Method hyperparameters: "),
)

# input <- list(
#   id = unique(data$id)[3],
#   n_future = 12,
#   method = "ETS",
#   error = "auto",
#   trend = "auto",
#   season = "auto",
#   damping = "auto",
#   smooth_level = 0.1,
#   smooth_trend = 0.1,
#   smooth_season = 0.1
# )
```


Row {data-height=700}
---------------------------------------------------------------------------

```{r}
ts_forecast_results <- eventReactive(
  eventExpr = input$apply_ts_forecast,
  valueExpr = {
    # data_pred <-
    data_filtered() |>
      generate_forecast(
        method = input$ts_method, params = input, 
        n_future = input$n_future, seed = 1992
      )
  }
)
```

### Forecasting Plot {.no-padding}

```{r}
output$plot_ts_forecast <- renderPlotly({
  ts_forecast_results()$forecast |> 
    plot_modeltime_forecast(.legend_show = FALSE, .title = FALSE)
})
plotlyOutput(outputId = "plot_ts_forecast")
```


Row {data-height=300}
---------------------------------------------------------------------------

### Model Summary {.no-padding}

```{r}
output$summary_ts_model <- renderPrint({
  ts_forecast_results()$model
})
verbatimTextOutput(outputId = "summary_ts_model")
```



ML Methods {data-navmenu="Forecast" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
sliderInput(
  inputId = "n_future", label = h4("Forecast Horizon"), 
  value = 12, min = 1, max = 60, step = 1
)

selectInput(
  inputId = "ml_method", label = h4("Forecast Method"), 
  choices = ml_methods, selected = ml_methods[1]
)

actionButton(inputId = "apply_ml_forecast", label = "Forecast!", icon = icon("play"))
actionButton(inputId = "ml_reset", label = "Reset", icon = icon("sync"))
observeEvent(
  eventExpr = input$ml_reset, 
  handlerExpr = {
    updateNumericInput(session = session, inputId = "n_future", value = 12)
    updateSelectInput(session = session, inputId = "ml_method", selected = ml_methods[1])
    shinyjs::delay(ms = 300, expr = {shinyjs::click(id = "apply_ml_forecast")})
  }
)

br() # break rule
br() # break rule

# Linear Regression
conditionalPanel(
  condition = "input.ml_method == 'Linear Regression'",
  h5("Method hyperparameters: "),
  h6("No hyperparameters for this method!")
  # input$none <- "none"
)

# Elastic Net
conditionalPanel(
  condition = "input.ml_method == 'Elastic Net'",
  h5("Method hyperparameters: "),
  numericInput(inputId = "penalty", label = "Penalty", value = 1, min = 0, max = 100),
  numericInput(inputId = "mixture", label = "Mixture", value = 1, min = 0, max = 1)
)

# input <- list(
#   id = unique(data$id)[3],
#   n_future = 12,
#   method = "Elastic Net",
#   penalty = 0.1,
#   mixture = 0.1
# )
```


Row {data-height=700}
---------------------------------------------------------------------------

```{r}
ml_forecast_results <- eventReactive(
  eventExpr = input$apply_ml_forecast,
  valueExpr = {
    # data_pred <-
    data_filtered() |>
      generate_forecast(
        method = input$ml_method, params = input,
        n_future = input$n_future, seed = 1992
      )
  }
)
```

### Forecasting Plot {.no-padding}

```{r}
output$plot_ml_forecast <- renderPlotly({
  ml_forecast_results()$forecast |> 
    plot_modeltime_forecast(.legend_show = FALSE, .title = FALSE)
})
plotlyOutput(outputId = "plot_ml_forecast")
```


Row {data-height=300}
---------------------------------------------------------------------------

### Model Summary {.no-padding}

```{r}
output$summary_ml_model <- renderPrint({
  ml_forecast_results()$model
})
verbatimTextOutput(outputId = "summary_ml_model")
```
